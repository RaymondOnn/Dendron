---
id: v8fsy06nfc9xo6bqq7f0ttn
title: github_actions
desc: ''
updated: 1711328373937
created: 1693757971078
---

- [SUPER_LINTER](https://github.com/super-linter/super-linter)


### What is GitHub Actions

-   A workflow automation service provided by Github
-   For automating repository-related processes and actions
    -   for e.g. CICD workflow i.e. code testing, building and deployment
-   CICD stands for Continous Integration Continuous Delivery
    -   CI: Code changes are automatically built, tested and merged with existing code
    -   CD: After integration, new app or package versions are published automatically

### Events

-   Most events are repository-related, there are some events that are not repository-related i.e. workflow dispatch, schedule

#### Filtering Events

-   Some events have **activity types** that give more detailed control over when a workflow will be triggered
    -   for e.g. trigger workflows only when pull_request event is opened, closed or edited etc
        ```yaml
        name: ...
        on:
            pull_request:
                types:
                    - opened
            workflow_dispatch:
        jobs: ...
        ```
-   Other events have **event filters** for e.g. trigger workflows on push events but filtered based on target branch

    ```yaml
    name: ...
    on:
        push:
            branches:
                - main
                - 'dev-*' # dev-new dev-this-is-new
                - 'feat/**'  # feat/new feat/new/button
            paths-ignore:
                - '.github/workflow/*
        workflow_dispatch:
    jobs:
        ...
    ```

-   Note: For people that forked your repo, edit and then created a pull request (i.e. first time contributors), workflow must be approved before they can be triggered automatically

### Job Data & Outputs

-   **Job artifacts** are output files generated by a job
-   We can upload and save these job artifacts that are produced by jobs for further actions such as

    -   download and use manually (via GitHub UI or REST API)
    -   download and use in other jobs (via actions)

        ```yaml
        ...
        jobs:
            build:
                needs: test
                runs-on: ubuntu-latest
                steps:
                    - name: Get Code
                        uses: actions/checkout@v3
                        ...
                    - name: Upload artifacts
                        uses: actions/upload-artifact@v3
                        with:
                            name: dist-files
                            path: |
                                dist
                                !package.json
            deploy:
                needs: test
                runs-on: ubuntu-latest
                steps:
                    - name: Download artifacts
                        uses: actions/upload-artifact@v3
                        with:
                            name: dist-files   # Note: Unzip is done automatically
        ```

-   **Job Outputs** are simple values produced by a job

    -   Typically the value is used in other jobs for e.g. name of file generated in previous build step
    - `echo "[OUTPUT_NAME]=[OUTPUT_VALUE]" >> $GITHUB_OUTPUT`
    ```yaml
      ...
      jobs:
          build:
              needs: test
              runs-on: ubuntu-latest
              outputs:
                  script-file: ${{ steps.publish.outputs.script-file }}
              steps:
                  - name: Get Code
                      uses: actions/checkout@v3
                      ...
                  - name: Publish JS filename
                      id: publish
                      uses: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
          deploy:
              needs: test
              runs-on: ubuntu-latest
              steps:
                  - name: Output filename
                      run: echo "${{ needs.build.outputs.script-file }}"

    ```

#### Dependency Caching

-   To avoid having to constantly install dependencies, we can cache the dependencies so that we only install dependencies when they change

    ```yaml
    ...
    jobs:
        test:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
                    ...
        build:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
                    ...

        deploy:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
    ```

### Controlling Execution Flow

#### Conditional Logic

-   Applicable to both Jobs and Steps
-   implemented via the `if` field.
-   Conditional logic evaluated via expressions. However, only for `if`, `${{ }}` is not required

###### Special Conditional Functions

-   By default, when a step fails, the job stops running
-   However, there are special conditional functions that can help override the behaviour
    -   `failure()`: return true when previous step / job failed
    -   `success()`: returns true when none of the previous steps have failed
    -   `always()`: causes the step tp always execute, even when cancelled
    -   `cancelled()`: returns true of the workflow has been cancelled

#### Continue-on-error

-   By default, when a job fails, other dependent jobs (`needs`) would be cancelled or aborted
-   `continue-on-error` indicates that the job should continue to run even if that particular step fails i.e. ignore errors
-   Typically, values for this field is better left hardcoded
    ```yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        test:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    # run install step if cache is not used
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: Run tests
                    continue-on-error: true
                    id: run-tests   # can use the id field to help reference steps
                    run: npm test
                - name: Upload test report # runs only if tests fail
                    if: failure() && steps.run-tests.outcome == 'failure'
                    uses: actions/upload-artifacts@v3
                    with:
                        name: test-report
                        path: test.json
        deploy:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Output Information
                    run: echo "Deploying..."
        report:
        # report job needs the final status of both test and deploy jobs to do its job
            if: failure()
            needs: [test, deploy]
            runs-on: ubuntu-latest
            steps:
                - name: Output Information
                    run: |
                        echo "Something went wrong"
                        echo " $ {{ github }}
    ```

#### Matrix

- The idea behind matrix is to be able to run on different combinations of parameters
- Note: By default, if one of the combinations fail, the job stops running.
- To better scope the combinations, 
  - `include`: to add specifc combination to the existing matrix
  - `exclude`: to remove specific combination from the existing matrix
  
    ``` yaml
    
    name: Matrix Demo
    on: push
    jobs:
        build:
            continue-on-error: true 
            strategy:
                matrix:
                    node-versions: [12, 14, 16]
                    operating-syatem: [ubuntu-latest, windows-latest]
                    include: 
                        - node-version: 18
                            operating-system: ubuntu-latest
                    exclude: 
                        - node-version: 12
                            operating-system: ubuntu-latest
            runs-on: ${{ matrix.operating-systems }}
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Install NodeJS
                    uses: action/setup-node@v3
                    with:
                        node-version: ${{ matrix.node-version }}
                - name: Installl Dependencies
                    run: npm ci
                - name: Build project
                    run: npm run build
     
    ```

#### Reusable Workflow aka Functions

- Reusable workflow helps with reducing code duplication
- 
    ``` yaml
    # ./.github/workflows/reusable.yaml
    name: Reusable Deploy
    on: workflow_call  # this allows this workflow to be used when needed
        inputs:
            artifact_name:
                description: The name of the deplotable artifact files
                required: false
                default: dist
                type: string
            secrets:
                some-secret:
                    required: false
        outputs:
            result:
                description: The result of the deployment operation
                value: ${{ jobs.deploy.outputs.outcome }}
    jobs: 
        deploy:
            outputs:
                outcome: ${{ steps.set-result.outputs.step-result }} 
            runs-on: ubuntu-latest
            steps:
                - name: Download artifact
                    uses: actions/download-artifact@v3
                    with:
                        name: ${{ inputs.artifact-name }}
                - List files
                    runs: ls
                - name: Output info
                    runs: echo 'Deploying...'
                - name: Set result output
                    run:  `echo "step-result=success" >> $GITHUB_OUTPUT`    

    ```

    ```yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        build:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: build website
                    id: build-website
                    run: npm run build
                - name: Upload artifact 
                    uses: actions/upload-artifacts@v3
                    with:
                        name: dist-files
                        path: dist
        deploy:
            needs: build
            # can also reference path in another repo
            uses: ./.github/workflows/reusable.yaml  # calling reusable workflow 
            with:
                artifact-name: dist-files
            secrets:
                some-secret: ${{ secrets.some-secret }}
        print-deploy-result:
            needs: deploy
            runs-on: ubuntu-latest
            steps:
                - name: Print deploy output
                    run: echo "${{ needs.deploy.outputs.result }}"
    ```

### Containers

- Containers are packages that contain code and its execution environment and allows for reproducible execution environment and results as the environment is isolated
- With Github actions, this means we have full control over the environment and installed software
  - The containerized job is hosted by the Runner
  - Steps execute inside the container
  - There is also **Services**: utility containers that host software needed by the steps for e.g. testing database
- Communicating to services:
  - container to container: Can leverage docker dns to get the ip address
  - host to container: Use ip address 127.0.0.1. Also will require to define the ports at both sides
    ``` yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        test:
            runs-on: ubuntu-latest
            container: 
                image: node: 16
                env: ...     # specific env variables for container here
            services: 
                mongodb:
                    image: mongo
                    ports:
                        - 27017:27017
                    env:
                        MONGO_INITDB_ROOT_USERNAME: root
                        MONGO_INITDB_ROOT_PASSWORD: example
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies 
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: Run tests
                    continue-on-error: true
                    id: run-tests   
                    run: npm test
                - name: Upload test report 
                    if: failure() && steps.run-tests.outcome == 'failure'
                    uses: actions/upload-artifacts@v3
                    with:
                        name: test-report
                        path: test.json
    ```

### Custom Actions   
- 3 ways to create custom actions
  1. Docker container action:
      - A Dockerfile is created and use to package the entire environment needed for GitHub Actions.
      - They bundle not only your code but also the specific OS, dependencies, tools, and runtime environment.
      - This packaging approach ensures consistency and reliability because the consumers of your action don’t need to worry about installing the necessary tools or dependencies themselves.
      - It tends to be slower than JavaScript action due to the time it takes to build and retrieve the container.
      - It can only execute on a Linux-based operating system. If you’re using self-hosted runners[¹], they must also be running a Linux-based operating system and have Docker installed to execute Docker container actions.
  2. JavaScript action:
     - A javascript file is executed directly on the runner[¹] machine.
     - These actions separate your action’s code from the environment used to run that code.
     - It ensures compatibility with all GitHub-hosted runners[¹] (including Ubuntu, Windows, and macOS).
     - It uses pure JavaScript and existing runner binaries.
     - GitHub Actions Toolkit offers Node.js packages for faster development.
  3. Composite action:
     - Composite actions combine multiple workflow steps into one action.
     - Say you have several run commands that you frequently use together in your workflows. With composite actions, you can bundle these commands into a single, well-defined action.
     - It simplifies workflows by creating reusable actions.
     - Using this composite action in your workflow makes your workflow configuration cleaner and more maintainable.
     - It is great for organizing complex workflows efficiently.
- Instructions for custom actions must be named `action.yaml`

#### Composite Actions
- Note the absence of the `on` key. Since they are used as part of a workflow, they do not need a trigger

    ``` yaml
    # ./.github/actions/cached-deps/action.yaml

    name: 'Get & Cache Dependencies'
    description: 'Get the dependencies (via npm) and cache them'
    inputs:
        caching:
            description: 'Whether to cache dependencies or not'   # this key is required
            required: false
            default: 'true'
    outputs:
        used-cache:
            description: 'Whether the cache was used'
            value: ${{ steps.install.outputs.cache }}
    runs:
        using: 'composite'
        steps:
            - name: Cache dependencies
                id: cache
                if: inputs.caching == 'true'   # <--- input value used here
                uses: actions/cache@v3
                with:
                    path: node_modules
                    key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
            - name: Install dependencies 
                id: install
                if: steps.cache.outputs.cache-hit != 'true' || inputs.caching != 'true'
                run: |
                    npm ci
                    echo "cache='${{ inputs.caching }}'" >> $GITHUB_OUTPUT
                shell: bash    # required if using `run` key

    ```

    ``` yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        test:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Load & cache deps       # <--- using custom action here
                    id: cache-deps
                    # if using file path, must start at root
                    # can also reference action in a repo: <ACCT_NAME>/<REPO_NAME>
                    uses: ./.github/actions/cached-deps
                    with:
                        caching: 'false'
                - name: Output Info
                    run: echo "Cache used? ${{ steps.cache-deps.outputs.used-cache }}"
                - name: Run tests
                    continue-on-error: true
                    id: run-tests   
                    run: npm test
                - name: Upload test report 
                    if: failure() && steps.run-tests.outcome == 'failure'
                    uses: actions/upload-artifacts@v3
                    with:
                        name: test-report
                        path: test.json
    ```

#### Javascript Actions
- s
    ``` yaml
    # ./.github/actions/deploy-s3-js/action.yaml
    
    name: 'Deploy to AWS S3'
    description: 'Deploy a static website via AWS S3'
    runs:
        using: 'node16'
        pre: 'setup.js' # optional
        main: 'main.js'
        post: 'cleanup.js' # optional
    ```

#### Docker Action
- s
    ``` yaml
    # ./.github/actions/deploy-s3-docker/action.yaml
    
    name: 'Deploy to AWS S3'
    description: 'Deploy a static website via AWS S3'
    # for every input, github actions generates an environment variable INPUT_<VARIABLE_NAME>
    inputs:
        bucket:
            description: 'The S3 bucket name'
            required: true
        bucket-region:
            description: 'The region of the S3 bucket'
            required: false
            default: 'us-east-1'
        dist-folder:
            description: 'The folder containg the deployable files'
            required: true
    outputs:
        website-url:
            description: 'The URL of the depolyed website'
            
    runs:
        using: 'docker'
        image: 'Dockerfile'
    ```
#### Storing Actions In Repositories & Sharing Actions With Others

- Alternatively, we could've stored the custom Actions in separate repositories (which therefore then only include the Action definition + code).
- This is actually quite straightforward:
  1. Create a new, local project folder which contains your action.yml file + all the code belonging to the action 
     - (Important: Don't put your `action.yml` file or code in a `.github/actions` folder or anything like that - just keep it directly on the root level of your created project!)
  2. Add a local Git repository to your created project (via git init)
  3. Create your commit(s) via `git add` and `git commit`
  4. Create a GitHub repository and connect it to your local Git repository (via `git remote add`)
  5. Add a tag via `git tag -a -m "My action release" v1`
  6. Push your local code to the remote GitHub repository (via `git push --follow tags`)
  7. Use your custom Action in any other Workflow (in any other project and repository) by referencing the repository which contains your action (e.g., `my-account/my-action@v1`)

- If your custom Action is stored in a public repository, it can also be published to the GitHub Actions Marketplace as described [here](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace#publishing-an-action)

### Security
- Script Injection Attacks
- Manage Permission via the `permission` key
- `$GITHUB_TOKEN`
- OpenID Connect
---

-   When something happens in/to your repo, automated actions are executed in response
-   **Events**

## Automating the process

1. Listen for events
2. Trigger workflows

## Why GitHub Actions?

-   if repo is in GitHub, use same tool instead of third party integration
-   setting up the CI/CD pipeline is easy
    -   integration with other technologies

## CI/CD Pipeline with Github Actions

```

```
