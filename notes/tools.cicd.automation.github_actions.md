---
id: v8fsy06nfc9xo6bqq7f0ttn
title: github_actions
desc: ""
updated: 1702537448494
created: 1693757971078
---

https://www.youtube.com/watch?v=PaGp7Vi5gfM&ab_channel=PatrickLoeber

https://www.youtube.com/watch?v=R8_veQiYBjI&t=3s&ab_channel=TechWorldwithNana

### What is GitHub Actions

-   A workflow automation service provided by Github
-   For automating repository-related processes and actions
    -   for e.g. CICD workflow i.e. code testing, building and deployment
-   CICD stands for Continous Integration Continuous Delivery
    -   CI: Code changes are automatically built, tested and merged with existing code
    -   CD: After integration, new app or package versions are published automatically

### Events

-   Most events are repository-related, there are some events that are not repository-related i.e. workflow dispatch, schedule

#### Filtering Events

-   Some events have **activity types** that give more detailed control over when a workflow will be triggered
    -   for e.g. trigger workflows only when pull_request event is opened, closed or edited etc
        ```yaml
        name: ...
        on:
            pull_request:
                types:
                    - opened
            workflow_dispatch:
        jobs: ...
        ```
-   Other events have **event filters** for e.g. trigger workflows on push events but filtered based on target branch

    ```yaml
    name: ...
    on:
        push:
            branches:
                - main
                - 'dev-*' # dev-new dev-this-is-new
                - 'feat/**'  # feat/new feat/new/button
            paths-ignore:
                - '.github/workflow/*
        workflow_dispatch:
    jobs:
        ...
    ```

-   Note: For people that forked your repo, edit and then created a pull request (i.e. first time contributors), workflow must be approved before they can be triggered automatically

### Job Data & Outputs

-   **Job artifacts** are output files generated by a job
-   We can upload and save these job artifacts that are produced by jobs for further actions such as

    -   download and use manually (via GitHub UI or REST API)
    -   download and use in other jobs (via actions)

        ```yaml
        ...
        jobs:
            build:
                needs: test
                runs-on: ubuntu-latest
                steps:
                    - name: Get Code
                        uses: actions/checkout@v3
                        ...
                    - name: Upload artifacts
                        uses: actions/upload-artifact@v3
                        with:
                            name: dist-files
                            path: |
                                dist
                                !package.json
            deploy:
                needs: test
                runs-on: ubuntu-latest
                steps:
                    - name: Download artifacts
                        uses: actions/upload-artifact@v3
                        with:
                            name: dist-files   # Note: Unzip is done automatically
        ```

-   **Job Outputs** are simple values produced by a job

    -   Typically the value is used in other jobs for e.g. name of file generated in previous build step
    - `echo "[OUTPUT_NAME]=[OUTPUT_VALUE]" >> $GITHUB_OUTPUT`
    ```yaml
      ...
      jobs:
          build:
              needs: test
              runs-on: ubuntu-latest
              outputs:
                  script-file: ${{ steps.publish.outputs.script-file }}
              steps:
                  - name: Get Code
                      uses: actions/checkout@v3
                      ...
                  - name: Publish JS filename
                      id: publish
                      uses: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
          deploy:
              needs: test
              runs-on: ubuntu-latest
              steps:
                  - name: Output filename
                      run: echo "${{ needs.build.outputs.script-file }}"

    ```

#### Dependency Caching

-   To avoid having to constantly install dependencies, we can cache the dependencies so that we only install dependencies when they change

    ```yaml
    ...
    jobs:
        test:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
                    ...
        build:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
                    ...

        deploy:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Cache dependencies
                    uses: actions/cache@v3
                    with:
                        path: ~/.npm
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    run: npm ci
    ```

### Controlling Execution Flow

#### Conditional Logic

-   Applicable to both Jobs and Steps
-   implemented via the `if` field.
-   Conditional logic evaluated via expressions. However, only for `if`, `${{ }}` is not required

###### Special Conditional Functions

-   By default, when a step fails, the job stops running
-   However, there are special conditional functions that can help override the behaviour
    -   failure(): return true when previous step / job failed
    -   success(): returns true when none of the previous steps have failed
    -   always(): causes the step tp always execute, even when cancelled
    -   cancelled(): returns true of the workflow has been cancelled

#### Continue-on-error

-   By default, when a job fails, other dependent jobs (`needs`) would be cancelled or aborted
-   `continue-on-error` indicates that the job should continue to run even if that particular step fails i.e. ignore errors
-   Typically, values for this field is better left hardcoded
    ```yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        test:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    # run install step if cache is not used
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: Run tests
                    continue-on-error: true
                    id: run-tests   # can use the id field to help reference steps
                    run: npm test
                - name: Upload test report # runs only if tests fail
                    if: failure() && steps.run-tests.outcome == 'failure'
                    uses: actions/upload-artifacts@v3
                    with:
                        name: test-report
                        path: test.json
        deploy:
            needs: test
            runs-on: ubuntu-latest
            steps:
                - name: Output Information
                    run: echo "Deploying..."
        report:
        # report job needs the final status of both test and deploy jobs to do its job
            if: failure()
            needs: [test, deploy]
            runs-on: ubuntu-latest
            steps:
                - name: Output Information
                    run: |
                        echo "Something went wrong"
                        echo " $ {{ github }}
    ```

#### Matrix

- The idea behind matrix is to be able to run on different combinations of parameters
- Note: By default, if one of the combinations fail, the job stops running.
- To better scope the combinations, 
  - `include`: to add specifc combination to the existing matrix
  - `exclude`: to remove specific combination from the existing matrix
  
    ``` yaml
    
    name: Matrix Demo
    on: push
    jobs:
        build:
            continue-on-error: true 
            strategy:
                matrix:
                    node-versions: [12, 14, 16]
                    operating-syatem: [ubuntu-latest, windows-latest]
                    include: 
                        - node-version: 18
                            operating-system: ubuntu-latest
                    exclude: 
                        - node-version: 12
                            operating-system: ubuntu-latest
            runs-on: ${{ matrix.operating-systems }}
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Install NodeJS
                    uses: action/setup-node@v3
                    with:
                        node-version: ${{ matrix.node-version }}
                - name: Installl Dependencies
                    run: npm ci
                - name: Build project
                    run: npm run build
     
    ```

#### Reusable Workflow aka Functions

- Reusable workflow helps with reducing code duplication
- 
    ``` yaml
    # ./.github/workflows/reusable.yaml
    name: Reusable Deploy
    on: workflow_call  # this allows this workflow to be used when needed
        inputs:
            artifact_name:
                description: The name of the deplotable artifact files
                required: false
                default: dist
                type: string
            secrets:
                some-secret:
                    required: false
        outputs:
            result:
                description: The result of the deployment operation
                value: ${{ jobs.deploy.outputs.outcome }}
    jobs: 
        deploy:
            outputs:
                outcome: ${{ steps.set-result.outputs.step-result }} 
            runs-on: ubuntu-latest
            steps:
                - name: Download artifact
                    uses: actions/download-artifact@v3
                    with:
                        name: ${{ inputs.artifact-name }}
                - List files
                    runs: ls
                - name: Output info
                    runs: echo 'Deploying...'
                - name: Set result output
                    run:  `echo "step-result=success" >> $GITHUB_OUTPUT`    

    ```

    ```yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        build:
            runs-on: ubuntu-latest
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: build website
                    id: build-website
                    run: npm run build
                - name: Upload artifact 
                    uses: actions/upload-artifacts@v3
                    with:
                        name: dist-files
                        path: dist
        deploy:
            needs: build
            # can also reference path in another repo
            uses: ./.github/workflows/reusable.yaml  # calling reusable workflow 
            with:
                artifact-name: dist-files
            secrets:
                some-secret: ${{ secrets.some-secret }}
        print-deploy-result:
            needs: deploy
            runs-on: ubuntu-latest
            steps:
                - name: Print deploy output
                    run: echo "${{ needs.deploy.outputs.result }}"
    ```

### Containers

- Containers are packages that contain code and its execution environment and allows for reproducible execution environment and results as the environment is isolated
- With Github actions, this means we have full control over the environment and installed software
  - The containerized job is hosted by the Runner
  - Steps execute inside the container
  - There is also **Services**: utility containers that host software needed by the steps for e.g. testing database
- Communicating to services:
  - container to container: Can leverage docker dns to get the ip address
  - host to container: Use ip address 127.0.0.1. Also will require to define the ports at both sides
    ``` yaml
    name: Deploy Project
    on: [push, workflow_dispatch]
    jobs:
        test:
            runs-on: ubuntu-latest
            container: 
                image: node: 16
                env: ...     # specific env variables for container here
            services: 
                mongodb:
                    image: mongo
                    ports:
                        - 27017:27017
                    env:
                        MONGO_INITDB_ROOT_USERNAME: root
                        MONGO_INITDB_ROOT_PASSWORD: example
            steps:
                - name: Get Code
                    uses: actions/checkout@v3
                - name: Cache dependencies
                    id: cache
                    uses: actions/cache@v3
                    with:
                        path: node_modules
                        key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
                - name: Install dependencies 
                    if: steps.cache.outputs.cache-hit != 'true'
                    run: npm ci
                - name: Run tests
                    continue-on-error: true
                    id: run-tests   
                    run: npm test
                - name: Upload test report 
                    if: failure() && steps.run-tests.outcome == 'failure'
                    uses: actions/upload-artifacts@v3
                    with:
                        name: test-report
                        path: test.json
    ```

### Custom Actions   
### Security
---

-   When something happens in/to your repo, automated actions are executed in response
-   **Events**

## Automating the process

1. Listen for events
2. Trigger workflows

## Why GitHub Actions?

-   if repo is in GitHub, use same tool instead of third party integration
-   setting up the CI/CD pipeline is easy
    -   integration with other technologies

## CI/CD Pipeline with Github Actions

```

```
